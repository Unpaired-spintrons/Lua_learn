# 函数

函数作用简单来看可有二

* 完成指定任务
* 来计算并返回数值

## 语法

```lua
function 函数名 (参数表)
   执行部分
end;
```

即使参数表为空，也要使用 () 符号表示函数调用

但上述的 () 规则遇到如下两种情况是可以打破的(但是还是尽量正常写吧)这两种情况 () 是可选的

* 函数只有一个参数，且参数为字符串
* 函数只有一个参数，且参数为table

e.g

```lua
print "hello"               --等同于print("hello")
function_a {x = 10, y = 20} --等同于function_a({x = 10, y = 20})
```

### 面向对象式调用

在table表中引入函数作为成员时，可用

```lua
table1.function1(……)
table2:function2(……) --这二者是等价的调用方式
```

### 编写特性

**$\color{orange}Lua的函数可以使用其他语言进行编写不一定要使用lua来进行编写$**

### 参数匹配

Lua的函数的参数表赋值与Lua的赋值匹配相同，多余被忽略，缺少的以nil值进行补足

```lua
function f(a , b)
   return a or b
end

f(3)              --传入的值为(3,nil)
f(3 , 4)          --传入的值为(3,4)
f(3 , 4 , 5)      --传入的值为(3,4)
```

## 返回多个值

Lua的函数可以返回多个值，并且不限种类，可以混合

```lua
function a(……)
   ……
   return 变量1,变量2……
end
```

在接收时，注意要使用多个变量接收，即使是table变量如果不加申明(标明索引一个一个写)，如果是空表多余量被忽略，只接收第一个值且表退化为变量，如果是非空只接报错

```lua
local function f3(a,b,c)
   return a,b,c
end

local w = {}
w = f3(1,"Spring Festival",false) --只接收第一个返回值，并且是空表的话退化到变量
local w1 = {1，3，4}
w1 = f3(1,"Spring Festival",false)--报错
local w2 = {}
w2[1],w2[2],w2[6] = f3(1,"Spring Festival",false) --正确，都收到了
```

### 三种不同返回值情况

```lua
function f00() end                --返回nil
function f01() return "a" end     --返回一个值
function f02() return "q","w" end --返回多个值

--如果接收变量数 > 返回值数量，则多余部分都为nil
```

#### 函数返回值和其他值混合赋予

* **当函数作为最后一个值或唯一一个值时，返回所有返回值**

  ```lua
  function f03() return "a","b" end
  x,y = f03()     --x="a",y="b"返回完全
  x,y,z = 20,f03()--x=20,y="a",z="b"返回完全
  ```
* **当函数不为最后一个时，只返回第一个值**

  ```lua
  function f03() return "a","b" end
  x,y = f03(),20  --x="a",y=20返回不完全
  ```
* **以上调用规则在直接调用作为函数参数时依然有效**

  ```lua
  function f03() return "a","b" end
  print(f03())    --全返回全使用作为函数参数
  print(20,f03()) --全返回全使用作为函数参数
  print(f03(),20) --不全返回全使用作为函数参数，只返回第一个
  print(fo3()..20)--不全返回全使用作为函数参数，只返回第一个
  ```
* **返回值作为初始化表参数时以上一二规则依然有效**

  ```lua
  function f03() return "a","b" end
  local w = {f03()}    --全返回作为参数
  local w2 = {20,f03()}--全返回作为参数
  local w3 = {f03(),20}--只返回第一个作为参数
  ```
* **return f()调用会返回f()的返回值，返回规则同一二**

  ```lua
  function f03() return "a","b" end
  function f04() return f03() end   --全返回
  function f05() return 20,f03() end--全返回
  function f04() return f03(),20 end--只返回第一个
  ```
* **函数外面加括号强制返回第一个**

  ```lua
  function f03() return "a","b" end
  x,y = (f03())
  print((f03()))  --以上两种情况返回都强制只返回第一个
  ```

#### unpack函数

返回数组中的所有值(不是table，自定义的带指代的都不可用，自定义的索引也不可用)

**$\color{red}最后可用版本5.1$**

## 可变参数

Lua可以接收可变数目的参数 **$\color{red}和C语言类似都是使用三点(...)表示函数有可变参数$**

**$\color{orange}...$** 会生成一个arg表，可变的参数就都收入arg表中

示例：重写print

```lua
local printResult = ""

local function print(...)
   for i,v in ipairs(arg) do
      printResult = printResult .. tostring(v) .. "\t"
   end
   printResult = printResult .. "\n"
end
```

固定几个参数再加可变参数

```lua
function g(a , b , ...)  --前两个参数都由a，b接收，之后的才由arg表接收
   ……
end
```

虚变量忽略写法类似于matlab当中~的写法

```lua
local _,x = f1()  --假设f1()有2个输出，但你只想要第二个
local _,_,z = f2()--假设f2()有3个输出，但你只想要第三个
--下划线_就是省略符，他们可以占用变量读取位，但并不保存他们
```

## 命名函数

是我们的函数调用一个固定格式的表，这个表中的变量用指代来确定

```lua
local function change(bian)
   bian.old,bian.new = bian.new,bian,old --一个交换函数这样写就显得简洁明了，但table也要适配
end

local x = {old = "2023", new = "2020"}
change(x)
```

## 函数特性

* **在Lua中函数并不是形参，如果在函数内部改变了值，在外部它也改变了，Lua传的是一个指针**

# 再论函数

Lua中的函数是带有此法界定(lexical scoping)的第一类值(first-class value)

#### 第一类值

**Lua中的函数和其他值(数值，字符串)一样，可以被存放在变量中，表中，甚至是作为函数的返回值，函数的参数**

#### 词法界定

**被嵌套的函数，可以访问嵌套他的和外部的变量**

#### 函数是一个变量

在Lua中我们可以发现一个十分有趣的事实，既然变量值可以是函数，那么函数也可以是一个变量！

我们可以将我们访问的每一个函数看成是在访问这个变量()只是使他们可以用而已。

重新去搬运指代一个函数变得十分简单

```lua
local a = {p = print} --此时a.p()就是print()了
```

在C语言中我们需要这样做

```c
void a(string x){
   printf(x);
}
```

我们可以很便捷的重新命名自己的space

我们可以用这个函数也是变量的方法去展现一些独特的技巧（语法的甜头syntactic sugar）

```lua
local f0 = function (x)
   …… --执行语句
end;  --这样也是一个函数，也可以说是一个变量赋值了
```

可以说我的变量赋值了，赋值了一个为function……end的值，和table表类似。

因此，我们可以使用函数作为参数，这样也一样可以形成函数，这种函数我们一般称为是高级函数，他没什么特权，没什么特别的，只是Lua中将函数看为变量的一种结果罢了

## 闭包

当一个函数内部嵌套另一个函数定义时，内部函数体可以访问外部的函数局部变量，这就是**词法定界**

看起来这是容易理解的，但是**第一类函数**+**词法定界**在编程语言中是一个十分强大的功能，很少语言支持这种操作

我们可以这样理解，就是函数当中直接去改变了一个它外部的参数。

例子：

```lua
function new()
   local i = 0
   return function()
             i = i + 1
             return i
          end
end

c1 = new()  --这个表明我们使用的是该函数的返回(在这个里面就是下面那个function)
print(c1()) --调用第一次返回值为1
print(c1()) --调用第二次返回值为2
--由于我们在使用c1()的时候使用的是return的function，而他的截止end并不在外部的new中，则就是一直在new()这个函数域中，所以会被叠加，它访问了外部的变量，这个访问原则依然遵循先局部的原则
```

以上就是函数闭包的例子，我们可以发现，Lua中可以在不加申明的情况下直接对应外部变量进行调用，那个外部变量如果不存在那就是nil值罢了，再看下面一个例子

```lua
local cc = 0
local function hee()
    cc = cc + 10
    return cc
end

print(hee()) --输出10
print(hee()) --输出20
```

在不加声明的情况下，他直接获得了外部变量cc，这就是lua的厉害之处，我认为他是将其作为一个C++类的操作，所有的世界均是在一个C++类中，这样看起来就有迹可循了

当然，这种闭包可以用在函数的返回中(retur的是一个函数，这个函数操作函数内部的变量，形成闭包，做出类似于C++类的效果)

这也同样适用于table表，table表就是自己创建的一个空间。

换句话说，函数会自动的调用你所要调用的各种变量和函数，在Lua中，由于nil值的存在，你所调用的东西一定会存在，调用的顺序是先局部后全局的思想。

### 闭包的作用

闭包的作用十分强大

* **可以方便的重新定义一函数和接口**
* **减少了函数使用的严谨性，就算他们不存在，你依然可以调用他们，返回为nil，极大减少了限制**
* **可以创建安全的环境(Java中称为沙箱)，可以定义一个空间，来定义自己的接口和访问，保证正常运行(进入自己的小空间)**

## 非全局函数

Lua中，函数可以作为全局变量也可以作为局部变量(table表中的变量)这种实现就像C++中的类一样，十分好用，由于我认为Lua是简化版的C++(或者在易用性上远胜于C++)
